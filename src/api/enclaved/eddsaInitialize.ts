import * as bitgoSdk from '@bitgo/sdk-core';
import { KmsClient } from '../../kms/kmsClient';
import * as crypto from 'crypto';
import {
  EnclavedApiSpecRouteRequest,
  MpcInitializeRequestType,
} from '../../enclavedBitgoExpress/routers/enclavedApiSpec';
import * as openpgp from 'openpgp';

export async function eddsaInitialize(
  req: EnclavedApiSpecRouteRequest<'v1.mpc.eddsa.initialize', 'post'>,
) {
  // request parsing
  const { source, bitgoGpgPub, counterPartyGpgPub }: MpcInitializeRequestType = req.decoded;
  if (!source) {
    throw new Error('Source is required for MPC initialization');
  }

  // setup clients
  const kms = new KmsClient(req.config);

  // MPC configuration
  const MPC = await bitgoSdk.Eddsa.initialize();
  const m = 2;
  const n = 3;

  // source key share generation. 1 is self, 2 is counterParty, 3 is BitGo
  const keyShare: bitgoSdk.KeyShare = MPC.keyShare(1, m, n);
  const myGpgKey = await bitgoSdk.generateGPGKeyPair('secp256k1');

  // key share generated by myself for myself
  const myPrivateKeyShare = keyShare.uShare;

  // public share used in both bitgo and counterPartySource key share
  const publicKeyShare = Buffer.concat([
    Buffer.from(keyShare.uShare.y, 'hex'),
    Buffer.from(keyShare.uShare.chaincode, 'hex'),
  ]).toString('hex');

  // construct sourceToBitGo key share
  const bitgoPrivateKeyShare = Buffer.concat([
    Buffer.from(keyShare.yShares[3].u, 'hex'),
    Buffer.from(keyShare.yShares[3].chaincode, 'hex'),
  ]).toString('hex');

  const bitgoKeyShare = {
    from: source,
    to: 'bitgo',
    publicShare: publicKeyShare,
    privateShare: gpgEncrypt(bitgoPrivateKeyShare, bitgoGpgPub),
    privateShareProof: await bitgoSdk.createShareProof(
      myGpgKey.privateKey,
      bitgoPrivateKeyShare.slice(0, 64),
      'eddsa',
    ),
    vssProof: keyShare.yShares[3].v,
    gpgPublicKey: myGpgKey.publicKey,
  };

  // construct sourceToCounterParty key share
  const counterPartyPrivateKeyShare = Buffer.concat([
    Buffer.from(keyShare.yShares[2].u, 'hex'),
    Buffer.from(keyShare.yShares[2].chaincode, 'hex'),
  ]).toString('hex');

  const counterPartyKeyShare = {
    from: source,
    to: source === 'user' ? 'backup' : 'user',
    publicShare: publicKeyShare,
    privateShare: gpgEncrypt(counterPartyPrivateKeyShare, counterPartyGpgPub),
    privateShareProof: await bitgoSdk.createShareProof(
      myGpgKey.privateKey,
      bitgoPrivateKeyShare.slice(0, 64),
      'eddsa',
    ),
    vssProof: keyShare.yShares[2].v,
    gpgPublicKey: myGpgKey.publicKey,
  };

  // construct encrypted payload. EBE receives back this payload in finalize since it can't keep it in memory
  const payload = {
    gpgPrv: myGpgKey.privateKey,
    myPrivateKeyShare,
  };
  const { plaintextKey, encryptedKey } = await kms.generateDataKey({ keyType: 'AES-256' });
  const encryptedPayload = crypto
    .publicEncrypt(Buffer.from(plaintextKey), Buffer.from(JSON.stringify(payload)))
    .toString();

  return {
    encryptedDataKey: encryptedKey,
    encryptedData: encryptedPayload,
    bitgoKeyShare,
    counterPartyKeyShare,
  };
}

/**
 * Helper function to encrypt text using OpenPGP
 */
async function gpgEncrypt(text: string, key: string): Promise<string> {
  return await openpgp.encrypt({
    message: await openpgp.createMessage({ text }),
    encryptionKeys: await openpgp.readKey({ armoredKey: key }),
    format: 'armored',
    config: {
      rejectCurves: new Set(),
      showVersion: false,
      showComment: false,
    },
  });
}
