import * as bitgoSdk from '@bitgo/sdk-core';
import { KmsClient } from '../../kms/kmsClient';
import * as crypto from 'crypto';
import {
  EnclavedApiSpecRouteRequest,
  InitEddsaKeyGenerationResponse,
  KeySharePayloadType,
} from '../../enclavedBitgoExpress/routers/enclavedApiSpec';
import * as openpgp from 'openpgp';

export async function eddsaInitialize(
  req: EnclavedApiSpecRouteRequest<'v1.mpc.eddsa.initialize', 'post'>,
): Promise<InitEddsaKeyGenerationResponse> {
  // request parsing
  const { source, bitgoGpgKey, userGpgKey } = req.decoded;
  if (source === 'backup' && !userGpgKey) {
    throw new Error('userGpgKey is required on backup key share generation');
  }

  // setup clients
  // const kms = new KmsClient(req.config);

  // MPC configuration
  const MPC = await bitgoSdk.Eddsa.initialize();
  const m = 2;
  const n = 3;

  // source key share generation. 1 is self, 2 is counterParty, 3 is BitGo
  const keyShare: bitgoSdk.KeyShare = MPC.keyShare(source === 'user' ? 1 : 2, m, n);
  const myGpgKey = await bitgoSdk.generateGPGKeyPair('secp256k1');

  // key share generated by myself for myself
  const myPrivateKeyShare = keyShare.uShare;

  // public share used in both bitgo and counterPartySource key share
  const publicKeyShare = Buffer.concat([
    Buffer.from(keyShare.uShare.y, 'hex'),
    Buffer.from(keyShare.uShare.chaincode, 'hex'),
  ]).toString('hex');

  // construct sourceToBitGo key share
  const bitgoPrivateKeyShare = Buffer.concat([
    Buffer.from(keyShare.yShares[3].u, 'hex'),
    Buffer.from(keyShare.yShares[3].chaincode, 'hex'),
  ]).toString('hex');

  const bitgoKeyShare: KeySharePayloadType = {
    from: source,
    to: 'bitgo',
    publicShare: publicKeyShare,
    privateShare: await gpgEncrypt(bitgoPrivateKeyShare, bitgoGpgKey),
    privateShareProof: await bitgoSdk.createShareProof(
      myGpgKey.privateKey,
      bitgoPrivateKeyShare.slice(0, 64),
      'eddsa',
    ),
    vssProof: keyShare.yShares[3].v as string,
    gpgKey: myGpgKey.publicKey,
  };

  let userKeyShare: KeySharePayloadType | undefined = undefined;

  if (userGpgKey) {
    // construct sourceToCounterParty key share
    console.log(keyShare);
    const counterPartyPrivateKeyShare = Buffer.concat([
      Buffer.from(keyShare.yShares[1].u, 'hex'),
      Buffer.from(keyShare.yShares[1].chaincode, 'hex'),
    ]).toString('hex');

    userKeyShare = {
      from: source,
      to: 'user',
      publicShare: publicKeyShare,
      privateShare: await gpgEncrypt(counterPartyPrivateKeyShare, userGpgKey),
      privateShareProof: await bitgoSdk.createShareProof(
        myGpgKey.privateKey,
        counterPartyPrivateKeyShare.slice(0, 64),
        'eddsa',
      ),
      vssProof: keyShare.yShares[1].v as string,
      gpgKey: myGpgKey.publicKey,
    };
  }

  // construct encrypted payload. EBE receives back this payload in finalize since it can't keep it in memory
  // const payload = {
  //   gpgPrv: myGpgKey.privateKey,
  //   myPrivateKeyShare,
  // };
  // const { plaintextKey, encryptedKey } = await kms.generateDataKey({ keyType: 'AES-256' });
  // const encryptedPayload = crypto
  //   .publicEncrypt(Buffer.from(plaintextKey), Buffer.from(JSON.stringify(payload)))
  //   .toString();

  return {
    encryptedDataKey: 'test',
    encryptedData: JSON.stringify({ myPrivateKeyShare, myGpgKey }),
    bitgoPayload: bitgoKeyShare,
    userPayload: userKeyShare,
  };
}

/**
 * Helper function to encrypt text using OpenPGP
 */
async function gpgEncrypt(text: string, key: string): Promise<string> {
  const output = await openpgp.encrypt({
    message: await openpgp.createMessage({ text }),
    encryptionKeys: await openpgp.readKey({ armoredKey: key }),
    format: 'armored',
    config: {
      rejectCurves: new Set(),
      showVersion: false,
      showComment: false,
    },
  });
  return output.toString();
}
